|**变量**|**函数**|**面向对象**|**模板与泛型编程**|**内存管理**|
|:--:|:--:|:--:|:--:|:--:|
|[变量](#ch1)<br>|||[模板与泛型编程](#ch2)<br>|[内存管理](#ch3)<br>|

# 一.变量

## 1.类整型

**使用建议**
* 使用int执行整数运算，超过范围用long long，因为long一般和int大小一样
* 浮点运算用double，float通常精度不够而且双精度和单精度的计算相差无几。

<br>

## 4.类型转换
    **隐式转换**
    - ** 整形 ** ：多数表达式中，比int小的整形首先提升为较大的整形
    - ** 数组转化为指针 **
    - ** 指针的转化 **：0,nullptr转化为任意指针，任意指针转void
    - ** 转换时机 **：
        + 拷贝初始化
        + 算术或关系运算
        + 函数调用
    ** 显示 **
    + **static_cast**:只要不包含底层const，都可以使用。适用将较大算术类型转化为较小的算术类型
    + **const_cast**:只能改变底层const，例如指向const的指针（指向的对象不一定是常量，
    但是无法通过指针修改）如果指向的是常量，则结果未定义
    + **reinterpret_cast**：通常为算术对象的位模式提供较低层次上的重新解释。如将
    int*转换为char*。很危险！！！
    + **dynamic_cast**:一种动态类型识别。转换的目标类型，即type，是
    指针或者左右值引用，主要用于基类指针转换成派生类类型的指针，通常需要知道转换源和目标对的类型
    失败返回或者bad_cast异常。

### 4.2 算术转换

## 8.复合类型
### 8.1 引用
* ** 本质 **：引用并非对象，它只是为对象起了另一个名字
* ** 形式 **： `int &a = b`
* 非常量引用不能绑定到字面值或表达式的计算结果
* 一般来说，引用类型和绑定的对象类型需严格匹配
* 引用本身并非对象，不能定义引用的引用

### 8.2 指针
* 指针和引用不同，指针本身是一个对象
* 因为引用不是对象，没有实际的地址，所以不能定义指向引用的指针
* 指针是一个对象，所以存在对指针的引用
* 一般来说，指针类型和指向的对象类型需严格匹配
* 编译器并不负责检查试图拷贝或以其他方式访问无效指针
* 和试图使用未经初始化的变量一样，使用未经无效指针的后果无法估计
* **空指针**：不指向任何对象（不要混淆空指针和**空类型**的指针）
    * `int *p1 = nullptr;`
    * `int *p2 = 0`
    * `int *p3 = NULL;`
* 把int变量直接赋值给指针是错误的，即使变量的值恰好是0
* **空类型** 指针用于存放任意对象的地址

### 8.3 复合类型的声明
#### 1）非数组与复合类型的声明
**从右到左分析**

```
int *&r = p;//r是一个引用，引用一个int指针p
```
```
int *p1,p2;// p1是一个int*，p2是一个int
```

#### 2）数组与复合类型的复杂申明
**从数组名字开始，由内到外分析**

* 数组与指针的复杂申明
```
int(*Parray)[10] = &arr; // Parray 是一个指针，指向一个含有10个int的数组
```
* 数组与引用的复杂申明
    ```c++
    int (&arrRef)[10] = arr; //arrRef是一个引用，引用一个含有10个int的数组
    ```
* 数组与指针及引用的混合复杂申明
    ```c++
    ​int *(&arry)[10] = ptrs; //arry是一个引用，引用一个包含10个int指针的数组
    ```
## 9.const
### 1）const对象
* const对象必须初始化，因为创建后const对象的值就不能再改变，初始值可以是任意复杂的表达式
```
const int i = get_size();// 运行时初始化
const int j = 42;// 编译时初始化
```
* 只能在const类型的对象上执行不改变其内容的操作
* 默认状态下，const对象仅仅在文件内有效。多个文件的同名const对象等同于在不同文件中定义独立的变量
* 要在多个文件间共享同一const对象，需在定义和声明加上extern

### 2）const的引用（常量引用）
* 不能修改所绑定的对象
* 和非常量引用不同，常量引用可以使用字面值或任意表达式作为初始值（原因：绑定了一个临时常量）

### 3）指针与const
* **指向常量的指针**
```
const int *a = &b;
```
* **const指针**（**常量指针**）：不能修改指针，将一直指向一个地址，因此必须初始化。但是指向的对象不是常量的话，可以修改指向的对象
```
int *const a = &b;
cosnt double * const pip = &pi;//pip是一个常量指针，指向的对象是一个双精度浮点型常量
```

### 4）顶层const与底层const
* **顶层const**：无法修改指针本身（顶层是一种直接的关系）
```
const int ci = 123;
int *const a  = &b;
```
* **底层const**：无法修改所指的对象（底层是一种间接的关系）
    * 用于声明引用的const都是底层const

## 10.constexpr与常量表达式
*
